RLP是Recursive Length Prefix的简写。是以太坊中的序列化方法，以太坊的所有对象都会使用RLP方法序列化为字节数组。

```
字符串 “dog” = [ 0x83, ’d’, ‘o’, ‘g’ ]
列表 [ “cat”, “dog” ] = [ 0xc8, 0x83, ‘c’, ‘a’, ’t’, 0x83, ’d’, ‘o’, ‘g’ ]
空字符串 (‘null’) = [ 0x80 ]
空列表 = [ 0xc0 ]
数字 15 (’\x0f’) = [ 0x0f ]
数字 1024 (’\x04\x00’) = [ 0x82, 0x04, 0x00 ]
空子集合 [ [], [[]], [ [], [[]] ] ] = [ 0xc7, 0xc0, 0xc1, 0xc0, 0xc3, 0xc0, 0xc1, 0xc0 ]
字符串 “Lorem ipsum dolor sit amet, consectetur adipisicing elit” = [ 0xb8, 0x38, ‘L’, ‘o’, ‘r’, ‘e’, ’m’, ‘ ‘, … , ‘e’, ‘l’, ‘i’, ’t’ ]
```

序列化工具

> 属于相对较独立的工具库。

RLP实际只给以下两种类型数据编码：

1.　byte数组

2.　byte数组的数组，称之为列表

规则1：对于值在\[0, 127\]之间的单个字节，其编码是其本身。

规则2：如果byte数组长度l &lt;= 55，编码的结果是数组本身，再加上128+l作为前缀。

规则3：如果数组长度大于55， 编码结果第一个是183加数组长度的编码的长度，然后是数组长度的本身的编码，最后是byte数组的编码。

规则1~3定义了byte数组的编码方案，下面介绍列表的编码规则。在此之前，我们先定义列表长度是指子列表编码后的长度之和。

规则4：如果列表长度小于55，编码结果第一位是192加列表长度的编码的长度，然后依次连接各子列表的编码。

注意规则4本身是递归定义的。

规则5：如果列表长度超过55，编码结果第一位是247加列表长度的编码长度，然后是列表长度本身的编码，最后依次连接各子列表的编码。

规则5本身也是递归定义的，和规则3相似。





