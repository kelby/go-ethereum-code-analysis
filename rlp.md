RLP是Recursive Length Prefix的简写。是以太坊中的序列化方法，以太坊的所有对象都会使用RLP方法序列化为字节数组。

递归长度前缀编码

```
字符串 “dog” = [ 0x83, ’d’, ‘o’, ‘g’ ]
列表 [ “cat”, “dog” ] = [ 0xc8, 0x83, ‘c’, ‘a’, ’t’, 0x83, ’d’, ‘o’, ‘g’ ]
空字符串 (‘null’) = [ 0x80 ]
空列表 = [ 0xc0 ]
数字 15 (’\x0f’) = [ 0x0f ]
数字 1024 (’\x04\x00’) = [ 0x82, 0x04, 0x00 ]
空子集合 [ [], [[]], [ [], [[]] ] ] = [ 0xc7, 0xc0, 0xc1, 0xc0, 0xc3, 0xc0, 0xc1, 0xc0 ]
字符串 “Lorem ipsum dolor sit amet, consectetur adipisicing elit” = [ 0xb8, 0x38, ‘L’, ‘o’, ‘r’, ‘e’, ’m’, ‘ ‘, … , ‘e’, ‘l’, ‘i’, ’t’ ]
```

序列化工具

> 属于相对较独立的工具库。

## 两种类型数据：

RLP实际只给以下两种类型数据编码：

1.　byte数组

2.　byte数组的数组，称之为列表

## 5 条 RLP 编码规则：

规则1：对于值在\[0, 127\]之间的单个字节，其编码是其本身。

规则2：如果byte数组长度l &lt;= 55，编码的结果是数组本身，再加上128+l作为前缀。

规则3：如果数组长度大于55， 编码结果第一个是183加数组长度的编码的长度，然后是数组长度的本身的编码，最后是byte数组的编码。

规则1~3定义了byte数组的编码方案，下面介绍列表的编码规则。在此之前，我们先定义列表长度是指子列表编码后的长度之和。

规则4：如果列表长度小于55，编码结果第一位是192加列表长度的编码的长度，然后依次连接各子列表的编码。

注意规则4本身是递归定义的。

规则5：如果列表长度超过55，编码结果第一位是247加列表长度的编码长度，然后是列表长度本身的编码，最后依次连接各子列表的编码。

规则5本身也是递归定义的，和规则3相似。

## 5 条 RLP 解码规则：

1.　如果f∈ \[0,128\),　那么它是一个字节本身。

2.　如果f∈\[128,184\)，那么它是一个长度不超过55的byte数组，数组的长度为 l=f-128

3.　如果f∈\[184,192\)，那么它是一个长度超过55的数组，长度本身的编码长度ll=f-183,然后从第二个字节开始读取长度为ll的bytes，按照BigEndian编码成整数l，l即为数组的长度。

4.　如果f∈\(192,247\]，那么它是一个编码后总长度不超过55的列表，列表长度为l=f-192。递归使用规则1~4进行解码。

5.　如果f∈\(247,256\]，那么它是编码后长度大于55的列表，其长度本身的编码长度ll=f-247,然后从第二个字节读取长度为ll的bytes,按BigEndian编码成整数l，l即为子列表长度。然后递归根据解码规则进行解码。

